#!/bin/bash

umask 022
rm -f /usr/bin/helper
if ! [[ -e /usr/local/bin/helper ]]; then
	cat >/usr/local/bin/helper <<'EOF'
#!/usr/bin/python3

import os
import subprocess
from tkinter import *
import types

root = Tk()
root.title( 'Helper' )
root.option_add( '*Font', 'Helvetica 18' )

def stateful( func ):
	func.state = IntVar()
	return func

def tcb_display( self, i ):
	cb = self.acb_display[ i ]
	state = cb.state.get()
	if state != 1 and os.system( 'xrandr -q | grep -q ^%s.connected' % cb.display ):
		state = 1
		cb.state.set( state )
	os.system( 'xrandr --output LVDS-0 --auto --output %s ' % cb.display +
			   ( '--auto --left-of LVDS-0',
				 '--off',
				 '--auto --right-of LVDS-0' )[ state ] )

class Application( Frame ):
	@stateful
	def cb_dpms( self ):
		os.system( 'xset dpms 600 1200 1800'
				   if self.cb_dpms.state.get() else
				   'xset dpms 0 0 0' )

	def cb_kill( self ):
		os.system( 'pgrep pulseaudio | xargs -r kill' )

	def cb_suspend( self ):
		for cb, state in ( self.cb_dpms, 1 ),:
			if state != cb.state.get():
				cb.state.set( state )
				cb()
		self.w_reset_state()
		os.system( 'sudo /etc/init.d/cryptnmount restart; sudo pm-suspend' )
		self.w_reset_state()

	def w_init_state( self ):
		randr = subprocess.getoutput( 'xrandr -q' )
		displays = [] if -1 == randr.find( 'LVDS-0' ) else \
			[ x for x in ( x.split( ' ', 1 )[ 0 ] for x in randr.split( '\n' ) )
				if x not in ( '', 'VGA-0', 'LVDS-0', 'Screen' ) ]
		def displayful( i, func ):
			func.display = displays[ i ]
			return types.MethodType( stateful( func ), self )
		self.acb_display = tuple( map(
			lambda i: displayful( i, lambda self: tcb_display( self, i ) ),
			range( min( 2, len( displays ) ) ) ) )

	def w_reset_state( self ):
		self.cb_dpms.state.set( not not os.system( 'xset q | grep -q Standby:.0' ) )
		for cb in self.acb_display:
			state = os.system(
				'''
				line=`xrandr -q | grep ^%s`
				if [[ $line ]]; then
					if grep -q 'discon.*+' <<<$line; then
						xrandr --output LVDS-0 --auto --output %s --off
						exit 1
					fi
					grep -q + <<<$line || exit 1
					offset=`cut -d+ -f2 <<<$line`
					exit $((2 * ! ! offset))
				else
					exit -1
				fi
				''' % ( ( cb.display, ) * 2 ) ) // 256
			assert 0 <= state < 3
			cb.state.set( state )

	def w_create( self ):
		Checkbutton( self, text='DPMS', variable=self.cb_dpms.state,
					 command=self.cb_dpms ).grid( columnspan=3 )
		for i, cb in enumerate( self.acb_display ):
			for j, t in enumerate( ( 'L', 'N', 'R' ) ):
				Radiobutton( self, text=t, value=j, variable=cb.state,
							 command=cb ).grid( row=1 + i, column=j )
		Button( self, text='Kill Pulse', command=self.cb_kill ).grid(
			columnspan=3, sticky=W+E )
		Button( self, text='Suspend', command=self.cb_suspend ).grid(
			columnspan=3, sticky=W+E )

	def __init__( self, master ):
		Frame.__init__( self, master )
		self.pack()
		self.w_init_state()
		self.w_reset_state()
		self.w_create()

app = Application( master=root )
app.mainloop()
EOF
	chmod +x /usr/local/bin/helper
	sed -i 's;^sigaev.*;Cmnd_Alias NOTTY=/usr/sbin/pm-suspend,/etc/init.d/cryptnmount\nDefaults requiretty\nDefaults!NOTTY !requiretty\nsigaev ALL=NOPASSWD:ALL;' /etc/sudoers
	mkdir -p /etc/portage/patches/net-misc/rsync
	cat >/etc/portage/patches/net-misc/rsync/copy-devices.patch <<'EOF'
This patch adds the --copy-devices option, which will try to copy
the data inside a device instead of duplicating the device node.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/copy-devices.diff
    ./prepare-source
    ./configure                      (optional if already run)
    make

based-on: 40afd365cc8ca968fd16e161d24df5b8a8a520cc
diff --git a/generator.c b/generator.c
--- a/generator.c
+++ b/generator.c
@@ -39,6 +39,7 @@ extern int preserve_acls;
 extern int preserve_xattrs;
 extern int preserve_links;
 extern int preserve_devices;
+extern int copy_devices;
 extern int preserve_specials;
 extern int preserve_hard_links;
 extern int preserve_executability;
@@ -1751,7 +1752,7 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
 		goto cleanup;
 	}
 
-	if (!S_ISREG(file->mode)) {
+	if (!(S_ISREG(file->mode) || (copy_devices && IS_DEVICE(file->mode)))) {
 		if (solo_file)
 			fname = f_name(file, NULL);
 		rprintf(FINFO, "skipping non-regular file \"%s\"\n", fname);
diff --git a/options.c b/options.c
--- a/options.c
+++ b/options.c
@@ -48,6 +48,7 @@ int append_mode = 0;
 int keep_dirlinks = 0;
 int copy_dirlinks = 0;
 int copy_links = 0;
+int copy_devices = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
 int preserve_acls = 0;
@@ -348,6 +349,7 @@ void usage(enum logcode F)
   rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
   rprintf(F," -g, --group                 preserve group\n");
   rprintf(F,"     --devices               preserve device files (super-user only)\n");
+  rprintf(F,"     --copy-devices          copy device contents as regular file\n");
   rprintf(F,"     --specials              preserve special files\n");
   rprintf(F," -D                          same as --devices --specials\n");
   rprintf(F," -t, --times                 preserve modification times\n");
@@ -506,6 +508,7 @@ static struct poptOption long_options[] = {
   {"no-D",             0,  POPT_ARG_NONE,   0, OPT_NO_D, 0, 0 },
   {"devices",          0,  POPT_ARG_VAL,    &preserve_devices, 1, 0, 0 },
   {"no-devices",       0,  POPT_ARG_VAL,    &preserve_devices, 0, 0, 0 },
+  {"copy-devices",     0,  POPT_ARG_NONE,   &copy_devices, 0, 0, 0 },
   {"specials",         0,  POPT_ARG_VAL,    &preserve_specials, 1, 0, 0 },
   {"no-specials",      0,  POPT_ARG_VAL,    &preserve_specials, 0, 0, 0 },
   {"links",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },
@@ -2074,6 +2077,9 @@ void server_options(char **args, int *argc_p)
 	else if (remove_source_files)
 		args[ac++] = "--remove-sent-files";
 
+	if (copy_devices)
+		args[ac++] = "--copy-devices";
+
 	if (ac > MAX_SERVER_ARGS) { /* Not possible... */
 		rprintf(FERROR, "argc overflow in server_options().\n");
 		exit_cleanup(RERR_MALLOC);
diff --git a/rsync.c b/rsync.c
--- a/rsync.c
+++ b/rsync.c
@@ -34,6 +34,7 @@ extern int preserve_xattrs;
 extern int preserve_perms;
 extern int preserve_executability;
 extern int preserve_times;
+extern int copy_devices;
 extern int am_root;
 extern int am_server;
 extern int am_sender;
@@ -326,7 +327,8 @@ int read_ndx_and_attrs(int f_in, int *iflag_ptr, uchar *type_ptr,
 
 	if (iflags & ITEM_TRANSFER) {
 		int i = ndx - cur_flist->ndx_start;
-		if (i < 0 || !S_ISREG(cur_flist->files[i]->mode)) {
+		struct file_struct *file = cur_flist->files[i];
+		if (i < 0 || !(S_ISREG(file->mode) || (copy_devices && IS_DEVICE(file->mode)))) {
 			rprintf(FERROR,
 				"received request to transfer non-regular file: %d [%s]\n",
 				ndx, who_am_i());
diff --git a/sender.c b/sender.c
--- a/sender.c
+++ b/sender.c
@@ -309,6 +309,20 @@ void send_files(int f_in, int f_out)
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
+		/* On Linux systems (at least), st_size is typically 0 for devices.
+		 * If so, try to determine the actual device size. */
+		if (IS_DEVICE(st.st_mode) && st.st_size == 0) {
+			OFF_T off = lseek(fd, 0, SEEK_END);
+			if (off == (OFF_T) -1)
+				rsyserr(FERROR, errno, "failed to seek to end of %s to determine size", fname);
+			else {
+				st.st_size = off;
+				off = lseek(fd, 0, SEEK_SET);
+				if (off != 0)
+					rsyserr(FERROR, errno, "failed to seek back to beginning of %s to read it", fname);
+			}
+		}
+
 		if (st.st_size) {
 			int32 read_size = MAX(s->blength * 3, MAX_MAP_SIZE);
 			mbuf = map_file(fd, st.st_size, read_size, s->blength);
EOF
	cp ~sigaev/sandbox/rsync* /var/portage/distfiles
	setsid nohup sh -c 'emerge -1 rsync &' </dev/null >/dev/null 2>&1
fi
